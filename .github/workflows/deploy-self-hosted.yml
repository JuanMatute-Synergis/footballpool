name: Deploy to Self-Hosted Runner

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create data backup before deployment
      run: |
        echo "Creating backup before deployment..."
        if [ -f "./data/database.sqlite" ]; then
          # Create timestamped backup
          timestamp=$(date +%Y%m%d_%H%M%S)
          cp ./data/database.sqlite "./data/database.sqlite.backup.$timestamp"
          echo "‚úÖ Database backup created: database.sqlite.backup.$timestamp"
          
          # Also create a pre-deployment backup for immediate recovery if needed
          cp ./data/database.sqlite "./data/database.sqlite.pre-deploy"
          echo "‚úÖ Pre-deployment backup created"
          
          # Verify backup
          ls -la ./data/database.sqlite*
          
          # Also backup to Google Drive if configured
          if command -v rclone &> /dev/null && rclone lsd gdrive: > /dev/null 2>&1; then
            echo "üì§ Creating deployment backup to Google Drive..."
            ./scripts/backup-to-gdrive.sh || echo "‚ö†Ô∏è Google Drive backup failed (continuing deployment)"
          else
            echo "‚ÑπÔ∏è Google Drive backup not configured"
          fi
        else
          echo "‚ÑπÔ∏è No existing database found"
        fi

    - name: Preserve database by creating external backup
      run: |
        echo "=== Ensuring data preservation ==="
        
        # Stop accepting new requests gracefully
        docker compose stop nfl-picks || true
        
        # Create multiple backup strategies
        if [ -f "./data/database.sqlite" ]; then
          timestamp=$(date +%Y%m%d_%H%M%S)
          
          # 1. Create local backup
          cp "./data/database.sqlite" "./data/database.sqlite.backup.$timestamp"
          
          # 2. Create deployment safety backup  
          cp "./data/database.sqlite" "./database.deploy.backup"
          
          # 3. Google Drive backup
          if command -v rclone &> /dev/null && rclone lsd gdrive: > /dev/null 2>&1; then
            echo "üì§ Google Drive backup..."
            ./scripts/backup-to-gdrive.sh || echo "‚ö†Ô∏è Google Drive backup failed"
          fi
          
          echo "‚úÖ Multiple backups created"
          ls -la ./data/database.sqlite* ./database.deploy.backup 2>/dev/null || true
        fi

    - name: Build new image without affecting data
      run: |
        echo "Building new container image..."
        docker compose build --no-cache

    - name: Deploy with guaranteed data preservation
      run: |
        echo "Deploying with data preservation guarantee..."
        
        # Start new container
        docker compose up -d nfl-picks
        
        # Wait for container to initialize
        sleep 20
        
        # Check if database was reset (this shouldn't happen now)
        user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
        echo "User count after deployment: $user_count"
        
        # If database was reset, restore immediately
        if [ "$user_count" = "0" ] && [ -f "./database.deploy.backup" ]; then
          echo "üö® Database reset detected - performing immediate restoration"
          docker compose down
          cp "./database.deploy.backup" "./data/database.sqlite"
          docker compose up -d nfl-picks
          sleep 15
          
          # Verify restoration
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "User count after restoration: $user_count"
          
          if [ "$user_count" = "0" ]; then
            echo "‚ùå CRITICAL: Restoration failed"
            exit 1
          fi
        fi
        
        # Clean up deployment backup
        rm -f "./database.deploy.backup"

    - name: Verify data integrity after deployment
      run: |
        echo "=== Data integrity verification ==="
        ls -la ./data/ || echo "No data directory found"
        if [ -f "./data/database.sqlite" ]; then
          echo "Database size: $(du -h ./data/database.sqlite)"
          
          # Verify database is not empty and has users
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "User count after deployment: $user_count"
          
          if [ "$user_count" = "0" ]; then
            echo "‚ùå CRITICAL: Database appears to be empty after deployment!"
            echo "This indicates data loss occurred during deployment."
            exit 1
          else
            echo "‚úÖ Database integrity verified - $user_count users found"
          fi
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi

    - name: Verify deployment and data integrity
      run: |
        echo "Waiting for services to be ready..."
        sleep 30
        
        echo "=== Final verification ==="
        # Check if containers are running
        docker compose ps
        
        # Check database integrity
        if [ -f "./data/database.sqlite" ]; then
          echo "‚úÖ Database file exists: $(du -h ./data/database.sqlite)"
          
          # Test API connectivity and user count
          echo "Testing API health..."
          max_attempts=5
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
            
            if [ "$user_count" != "0" ] && [ "$user_count" != "null" ]; then
              echo "‚úÖ API responding with $user_count users"
              break
            else
              echo "‚è≥ Attempt $attempt/$max_attempts - API not ready or no users found"
              if [ $attempt -eq $max_attempts ]; then
                echo "‚ùå API failed to respond properly after $max_attempts attempts"
                
                # Emergency restoration from pre-deployment backup
                if [ -f "./data/database.sqlite.pre-deploy" ]; then
                  echo "üö® Attempting emergency restoration from pre-deployment backup..."
                  docker compose down
                  cp ./data/database.sqlite.pre-deploy ./data/database.sqlite
                  docker compose up -d
                  sleep 15
                  
                  # Verify restoration
                  user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                  echo "User count after emergency restoration: $user_count"
                  
                  if [ "$user_count" != "0" ]; then
                    echo "‚úÖ Emergency restoration successful"
                  else
                    echo "‚ùå Emergency restoration failed"
                    exit 1
                  fi
                else
                  echo "‚ùå No pre-deployment backup available for restoration"
                  exit 1
                fi
              else
                sleep 10
                attempt=$((attempt + 1))
              fi
            fi
          done
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi
        
        # Clean up pre-deployment backup on success
        rm -f ./data/database.sqlite.pre-deploy

    - name: Deployment complete
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "Application available at: http://localhost:4200"
        echo "Backend API at: http://localhost:3000"

    - name: Health check with retries
      run: |
        echo "Performing health check..."
        
        # Show container status
        docker compose ps
        
        # Try health check with retries
        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/api/games/live || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Health check passed - Application is running"
            echo "üöÄ Deployment successful!"
            exit 0
          else
            echo "‚è≥ Health check failed (attempt $i/5) - HTTP status: $response"
            if [ $i -eq 5 ]; then
              echo "‚ùå All health check attempts failed"
              echo "Container logs:"
              docker compose logs --tail=20
              exit 1
            fi
            sleep 10
          fi
        done

    - name: Show container logs on failure
      if: failure()
      run: |
        echo "=== Deployment Failed - Container Status ==="
        docker compose ps
        echo "=== Container Logs ==="
        docker compose logs --tail=50
