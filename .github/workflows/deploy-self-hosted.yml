name: Deploy to Self-Hosted Runner

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create data backup before deployment
      run: |
        echo "Creating backup before deployment..."
        if [ -f "./data/database.sqlite" ]; then
          # Create timestamped backup
          timestamp=$(date +%Y%m%d_%H%M%S)
          cp ./data/database.sqlite "./data/database.sqlite.backup.$timestamp"
          echo "‚úÖ Database backup created: database.sqlite.backup.$timestamp"
          
          # Also create a pre-deployment backup for immediate recovery if needed
          cp ./data/database.sqlite "./data/database.sqlite.pre-deploy"
          echo "‚úÖ Pre-deployment backup created"
          
          # Verify backup
          ls -la ./data/database.sqlite*
          
          # Also backup to Google Drive if configured
          if command -v rclone &> /dev/null && rclone lsd gdrive: > /dev/null 2>&1; then
            echo "üì§ Creating deployment backup to Google Drive..."
            ./scripts/backup-to-gdrive.sh || echo "‚ö†Ô∏è Google Drive backup failed (continuing deployment)"
          else
            echo "‚ÑπÔ∏è Google Drive backup not configured"
          fi
        else
          echo "‚ÑπÔ∏è No existing database found"
        fi

    - name: Verify data directory exists and preserve current state
      run: |
        echo "=== Current data state ==="
        ls -la ./data/ || echo "No data directory found"
        if [ -f "./data/database.sqlite" ]; then
          echo "Database size: $(du -h ./data/database.sqlite)"
          # Get current user count to verify data integrity
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "Current user count: $user_count"
        fi

    - name: Build new image without stopping containers
      run: |
        echo "Building new container image..."
        docker compose build --no-cache

    - name: Rolling deployment with zero data loss
      run: |
        echo "Performing rolling deployment to preserve data..."
        
        # Get the current container ID for reference
        current_container=$(docker compose ps -q nfl-picks || echo "")
        
        if [ -n "$current_container" ]; then
          echo "Current container: $current_container"
          
          # Perform rolling update - this stops old container and starts new one
          # but preserves the mounted volume data
          docker compose up -d --force-recreate --no-deps nfl-picks
          
          # Wait for new container to be healthy
          echo "Waiting for new container to be ready..."
          sleep 15
          
          # Verify the new container is running
          new_container=$(docker compose ps -q nfl-picks)
          echo "New container: $new_container"
        else
          echo "No existing container found, starting fresh..."
          docker compose up -d
          sleep 15
        fi

    - name: Verify data integrity after deployment
      run: |
        echo "=== Data integrity verification ==="
        ls -la ./data/ || echo "No data directory found"
        if [ -f "./data/database.sqlite" ]; then
          echo "Database size: $(du -h ./data/database.sqlite)"
          
          # Verify database is not empty and has users
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "User count after deployment: $user_count"
          
          if [ "$user_count" = "0" ]; then
            echo "‚ùå CRITICAL: Database appears to be empty after deployment!"
            echo "This indicates data loss occurred during deployment."
            exit 1
          else
            echo "‚úÖ Database integrity verified - $user_count users found"
          fi
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi

    - name: Verify deployment and data integrity
      run: |
        echo "Waiting for services to be ready..."
        sleep 30
        
        echo "=== Final verification ==="
        # Check if containers are running
        docker compose ps
        
        # Check database integrity
        if [ -f "./data/database.sqlite" ]; then
          echo "‚úÖ Database file exists: $(du -h ./data/database.sqlite)"
          
          # Test API connectivity and user count
          echo "Testing API health..."
          max_attempts=5
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
            
            if [ "$user_count" != "0" ] && [ "$user_count" != "null" ]; then
              echo "‚úÖ API responding with $user_count users"
              break
            else
              echo "‚è≥ Attempt $attempt/$max_attempts - API not ready or no users found"
              if [ $attempt -eq $max_attempts ]; then
                echo "‚ùå API failed to respond properly after $max_attempts attempts"
                
                # Emergency restoration from pre-deployment backup
                if [ -f "./data/database.sqlite.pre-deploy" ]; then
                  echo "üö® Attempting emergency restoration from pre-deployment backup..."
                  docker compose down
                  cp ./data/database.sqlite.pre-deploy ./data/database.sqlite
                  docker compose up -d
                  sleep 15
                  
                  # Verify restoration
                  user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                  echo "User count after emergency restoration: $user_count"
                  
                  if [ "$user_count" != "0" ]; then
                    echo "‚úÖ Emergency restoration successful"
                  else
                    echo "‚ùå Emergency restoration failed"
                    exit 1
                  fi
                else
                  echo "‚ùå No pre-deployment backup available for restoration"
                  exit 1
                fi
              else
                sleep 10
                attempt=$((attempt + 1))
              fi
            fi
          done
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi
        
        # Clean up pre-deployment backup on success
        rm -f ./data/database.sqlite.pre-deploy

    - name: Deployment complete
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "Application available at: http://localhost:4200"
        echo "Backend API at: http://localhost:3000"

    - name: Health check with retries
      run: |
        echo "Performing health check..."
        
        # Show container status
        docker compose ps
        
        # Try health check with retries
        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/api/games/live || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Health check passed - Application is running"
            echo "üöÄ Deployment successful!"
            exit 0
          else
            echo "‚è≥ Health check failed (attempt $i/5) - HTTP status: $response"
            if [ $i -eq 5 ]; then
              echo "‚ùå All health check attempts failed"
              echo "Container logs:"
              docker compose logs --tail=20
              exit 1
            fi
            sleep 10
          fi
        done

    - name: Show container logs on failure
      if: failure()
      run: |
        echo "=== Deployment Failed - Container Status ==="
        docker compose ps
        echo "=== Container Logs ==="
        docker compose logs --tail=50
