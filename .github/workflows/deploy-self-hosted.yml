name: Deploy to Self-Hosted Runner

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create data backup before deployment
      run: |
        echo "Creating backup before deployment..."
        if [ -f "./data/database.sqlite" ]; then
          # Create timestamped backup
          timestamp=$(date +%Y%m%d_%H%M%S)
          cp ./data/database.sqlite "./data/database.sqlite.backup.$timestamp"
          echo "‚úÖ Database backup created: database.sqlite.backup.$timestamp"
          
          # Also create a pre-deployment backup for immediate recovery if needed
          cp ./data/database.sqlite "./data/database.sqlite.pre-deploy"
          echo "‚úÖ Pre-deployment backup created"
          
          # Verify backup
          ls -la ./data/database.sqlite*
          
          # Also backup to Google Drive if configured
          if command -v rclone &> /dev/null && rclone lsd gdrive: > /dev/null 2>&1; then
            echo "üì§ Creating deployment backup to Google Drive..."
            ./scripts/backup-to-gdrive.sh || echo "‚ö†Ô∏è Google Drive backup failed (continuing deployment)"
          else
            echo "‚ÑπÔ∏è Google Drive backup not configured"
          fi
        else
          echo "‚ÑπÔ∏è No existing database found"
        fi

    - name: Smart deployment with data protection
      run: |
        echo "=== Smart Deployment Strategy ==="
        
        # Create multiple backup layers before ANY operations
        if [ -f "./data/database.sqlite" ]; then
          timestamp=$(date +%Y%m%d_%H%M%S)
          
          # Create backup directory if it doesn't exist
          mkdir -p ./backups
          
          # 1. Timestamped backup
          cp "./data/database.sqlite" "./data/database.sqlite.backup.$timestamp"
          
          # 2. Pre-deployment backup (for emergency restoration) - CRITICAL!
          cp "./data/database.sqlite" "./data/database.sqlite.pre-deploy"
          
          # 3. Working copy backup (to detect corruption)
          cp "./data/database.sqlite" "./database.working.backup"
          
          # 4. Extra safety backup in backups directory
          cp "./data/database.sqlite" "./backups/emergency-backup-$timestamp.sqlite"
          
          # Verify all backups were created
          echo "=== Backup Verification ==="
          ls -la ./data/database.sqlite*
          ls -la ./database.*.backup
          ls -la ./backups/emergency-backup-$timestamp.sqlite
          
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "‚úÖ All backups created. Current user count: $user_count"
          
          # 5. Google Drive backup
          if command -v rclone &> /dev/null && rclone lsd gdrive: > /dev/null 2>&1; then
            echo "üì§ Google Drive backup..."
            ./scripts/backup-to-gdrive.sh || echo "‚ö†Ô∏è Google Drive backup failed"
          fi
        else
          echo "‚ö†Ô∏è No database found to backup"
        fi

    - name: Build new image safely
      run: |
        echo "Building new container image (data directory excluded via .dockerignore)..."
        docker compose build --no-cache

    - name: Deploy with zero-downtime data protection
      run: |
        echo "Performing zero-downtime deployment..."
        
        # Stop current container gracefully
        docker compose stop nfl-picks || true
        sleep 3
        
        # Verify data is still intact after stopping
        if [ -f "./data/database.sqlite" ] && [ -f "./database.working.backup" ]; then
          if ! cmp -s "./data/database.sqlite" "./database.working.backup"; then
            echo "‚ö†Ô∏è Database changed during shutdown, restoring from working backup"
            cp "./database.working.backup" "./data/database.sqlite"
          fi
        fi
        
        # Ensure data directory exists and is properly owned
        sudo mkdir -p ./data
        sudo chown -R $(id -u):$(id -g) ./data
        ls -la ./data/
        
        # Start new container
        echo "Starting new container with volume mount verification..."
        docker compose up -d nfl-picks
        
        # Wait longer for proper volume mount and database initialization
        echo "Waiting for container to fully initialize with volume mount..."
        sleep 45
        
        # Check container logs for startup issues
        echo "=== Container startup logs ==="
        docker compose logs --tail=10 nfl-picks
        
        # Critical data integrity check with more attempts and patience  
        max_attempts=5
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          
          if [ "$user_count" != "0" ] && [ "$user_count" != "null" ]; then
            echo "‚úÖ Deployment successful! User count: $user_count"
            # Clean up working backup on success
            rm -f "./database.working.backup"
            break
          else
            echo "‚ùå Attempt $attempt/$max_attempts: User count is $user_count"
            echo "Container status:"
            docker compose ps
            echo "Recent container logs:"
            docker compose logs --tail=5 nfl-picks
            
            if [ $attempt -eq $max_attempts ]; then
              echo "üö® EMERGENCY: Deploying data recovery procedures"
              
              # Emergency stop and restore
              docker compose down
              
              # Try multiple backup sources in order of preference
              restored=false
              
              # 1. Try pre-deployment backup first (new fixed filename)
              if [ -f "./data/database.sqlite.pre-deploy" ]; then
                echo "Restoring from pre-deployment backup..."
                cp "./data/database.sqlite.pre-deploy" "./data/database.sqlite"
                docker compose up -d nfl-picks
                sleep 15
                
                # Verify emergency restoration
                user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                
                if [ "$user_count" != "0" ]; then
                  echo "‚úÖ Emergency restoration successful! User count: $user_count"
                  restored=true
                fi
              fi
              
              # 2. Try emergency backup from backups directory
              if [ "$restored" = false ]; then
                emergency_backup=$(ls -t ./backups/emergency-backup-*.sqlite 2>/dev/null | head -n1)
                if [ -f "$emergency_backup" ]; then
                  echo "Restoring from emergency backup: $emergency_backup"
                  cp "$emergency_backup" "./data/database.sqlite"
                  docker compose up -d nfl-picks
                  sleep 15
                  
                  user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                  
                  if [ "$user_count" != "0" ]; then
                    echo "‚úÖ Emergency backup restoration successful! User count: $user_count"
                    restored=true
                  fi
                fi
              fi
              
              # 3. Try any recent timestamped backup
              if [ "$restored" = false ]; then
                recent_backup=$(ls -t ./data/database.sqlite.backup.* 2>/dev/null | head -n1)
                if [ -f "$recent_backup" ]; then
                  echo "Restoring from recent backup: $recent_backup"
                  cp "$recent_backup" "./data/database.sqlite"
                  docker compose up -d nfl-picks
                  sleep 15
                  
                  user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                  
                  if [ "$user_count" != "0" ]; then
                    echo "‚úÖ Recent backup restoration successful! User count: $user_count"
                    restored=true
                  fi
                fi
              fi
              
              if [ "$restored" = false ]; then
                echo "‚ùå CRITICAL: All restoration attempts failed. Manual intervention required."
                echo "Available backups:"
                ls -la ./data/database.sqlite* 2>/dev/null || echo "No database backups found"
                ls -la ./backups/ 2>/dev/null || echo "No emergency backups found"
                exit 1
              fi
            else
              echo "Retrying in 20 seconds..."
              sleep 20
              attempt=$((attempt + 1))
            fi
          fi
        done
        
        # Clean up pre-deployment backup on success
        rm -f "./data/database.sqlite.pre-deploy"

    - name: Verify data integrity after deployment
      run: |
        echo "=== Data integrity verification ==="
        ls -la ./data/ || echo "No data directory found"
        if [ -f "./data/database.sqlite" ]; then
          echo "Database size: $(du -h ./data/database.sqlite)"
          
          # Verify database is not empty and has users
          user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
          echo "User count after deployment: $user_count"
          
          if [ "$user_count" = "0" ]; then
            echo "‚ùå CRITICAL: Database appears to be empty after deployment!"
            echo "This indicates data loss occurred during deployment."
            exit 1
          else
            echo "‚úÖ Database integrity verified - $user_count users found"
          fi
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi

    - name: Verify deployment and data integrity
      run: |
        echo "Waiting for services to be ready..."
        sleep 30
        
        echo "=== Final verification ==="
        # Check if containers are running
        docker compose ps
        
        # Check database integrity
        if [ -f "./data/database.sqlite" ]; then
          echo "‚úÖ Database file exists: $(du -h ./data/database.sqlite)"
          
          # Test API connectivity and user count
          echo "Testing API health..."
          max_attempts=5
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
            
            if [ "$user_count" != "0" ] && [ "$user_count" != "null" ]; then
              echo "‚úÖ API responding with $user_count users"
              break
            else
              echo "‚è≥ Attempt $attempt/$max_attempts - API not ready or no users found"
              if [ $attempt -eq $max_attempts ]; then
                echo "‚ùå API failed to respond properly after $max_attempts attempts"
                
                # Emergency restoration from pre-deployment backup
                if [ -f "./data/database.sqlite.pre-deploy" ]; then
                  echo "üö® Attempting emergency restoration from pre-deployment backup..."
                  docker compose down
                  cp ./data/database.sqlite.pre-deploy ./data/database.sqlite
                  docker compose up -d
                  sleep 15
                  
                  # Verify restoration
                  user_count=$(curl -s http://localhost:3001/api/auth/health | jq -r '.user_count // "0"' 2>/dev/null || echo "0")
                  echo "User count after emergency restoration: $user_count"
                  
                  if [ "$user_count" != "0" ]; then
                    echo "‚úÖ Emergency restoration successful"
                  else
                    echo "‚ùå Emergency restoration failed"
                    exit 1
                  fi
                else
                  echo "‚ùå No pre-deployment backup available for restoration"
                  exit 1
                fi
              else
                sleep 10
                attempt=$((attempt + 1))
              fi
            fi
          done
        else
          echo "‚ùå Database file missing after deployment!"
          exit 1
        fi
        
        # Clean up pre-deployment backup on success
        rm -f ./data/database.sqlite.pre-deploy

    - name: Deployment complete
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "Application available at: http://localhost:4200"
        echo "Backend API at: http://localhost:3000"

    - name: Health check with retries
      run: |
        echo "Performing health check..."
        
        # Show container status
        docker compose ps
        
        # Try health check with retries
        for i in {1..5}; do
          echo "Health check attempt $i/5..."
          
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/api/games/live || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Health check passed - Application is running"
            echo "üöÄ Deployment successful!"
            exit 0
          else
            echo "‚è≥ Health check failed (attempt $i/5) - HTTP status: $response"
            if [ $i -eq 5 ]; then
              echo "‚ùå All health check attempts failed"
              echo "Container logs:"
              docker compose logs --tail=20
              exit 1
            fi
            sleep 10
          fi
        done

    - name: Show container logs on failure
      if: failure()
      run: |
        echo "=== Deployment Failed - Container Status ==="
        docker compose ps
        echo "=== Container Logs ==="
        docker compose logs --tail=50
